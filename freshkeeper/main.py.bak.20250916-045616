import os
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.exc import IntegrityError
from fastapi.encoders import jsonable_encoder
from decimal import Decimal


# 1) Charger .env TÔT pour que DATABASE_URL soit dispo à l'import des routeurs
try:
    from dotenv import load_dotenv  # type: ignore
    load_dotenv()
except Exception:
    pass  # Si python-dotenv absent, variables déjà dans l'env

def _try_import(router_path: str):
    """Importe prudemment un router 'module:attr' et retourne l'objet ou None."""
    try:
        module_path, attr = router_path.split(":", 1)
    except ValueError:
        module_path, attr = router_path, "router"
    try:
        mod = __import__(module_path, fromlist=[attr])
        return getattr(mod, attr)
    except Exception:
        return None

APP_NAME = os.getenv("FRESHKEEPER_APP_NAME", "FreshKeeper API")
APP_VERSION = os.getenv("FRESHKEEPER_VERSION", "0.1.0")

app = FastAPI(title=APP_NAME, version=APP_VERSION)

# CORS (par défaut permissif; resserrer avec CORS_ALLOW_ORIGINS="http://192.168.1.18:19000,http://192.168.1.18:19006")
allow_origins = os.getenv("CORS_ALLOW_ORIGINS", "*").split(",")
app.add_middleware(
    CORSMiddleware,
    allow_origins=allow_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Health & root
@app.get("/")
def root():
    return {"message": f"{APP_NAME} is running", "version": APP_VERSION}

@app.get("/health")
def health():
    return {"status": "ok"}

# Monter les routeurs S'ILS EXISTENT (tous via freshkeeper.routers.*)
for path in [
    "freshkeeper.routers.storage_locations:router",
    "freshkeeper.routers.status:router",
    "freshkeeper.routers.maintenance:router",
    "freshkeeper.routers.lots:router",
    "freshkeeper.routers.alerts:router",
    "freshkeeper.routers.products:router",
]:
    r = _try_import(path)
    if r:
        app.include_router(r)

# /products/suggest (optionnel)
try:
    from freshkeeper.api.suggest import router as suggest_router  # type: ignore
    app.include_router(suggest_router, prefix="/products")
except Exception:
    pass
# --- Compatibilité pour clients mobiles qui appellent /api/* ---
try:
    from freshkeeper.routers import products as _prod
    from freshkeeper.routers import alerts as _alerts
    from freshkeeper.routers import lots as _lots
    app.include_router(_prod.router, prefix="/api")
    app.include_router(_alerts.router, prefix="/api")
    app.include_router(_lots.router, prefix="/api")
except Exception:
    pass

# (Optionnel) /api/products/suggest si dispo
try:
    from freshkeeper.api import suggest as _suggest
    app.include_router(_suggest.router, prefix="/api/products")
except Exception:
    pass
# --- Compatibilité clients mobiles: exposer aussi /api/* et /api/v1/* ---
try:
    from freshkeeper.routers import products as _prod
    from freshkeeper.routers import alerts as _alerts
    from freshkeeper.routers import lots as _lots
    for _prefix in ("/api", "/api/v1"):
        app.include_router(_prod.router,   prefix=_prefix)
        app.include_router(_alerts.router, prefix=_prefix)
        app.include_router(_lots.router,   prefix=_prefix)
except Exception:
    pass

# Miroir du /health sous /api et /api/v1
try:
    app.add_api_route("/api/health", health, methods=["GET"])
    app.add_api_route("/api/v1/health", health, methods=["GET"])
except Exception:
    pass
# --- ALIAS directs pour /api/products et /api/v1/products ---
try:
    from freshkeeper.routers import products as _prod

    # Liste
    app.add_api_route("/api/products", _prod.list_products, methods=["GET"], tags=["products"])
    app.add_api_route("/api/products/", _prod.list_products, methods=["GET"], tags=["products"])
    app.add_api_route("/api/v1/products", _prod.list_products, methods=["GET"], tags=["products"])
    app.add_api_route("/api/v1/products/", _prod.list_products, methods=["GET"], tags=["products"])

    # Détail
    app.add_api_route("/api/products/{product_id}", _prod.get_product, methods=["GET"], tags=["products"])
    app.add_api_route("/api/v1/products/{product_id}", _prod.get_product, methods=["GET"], tags=["products"])
except Exception:
    pass
from fastapi import Request
from starlette.responses import RedirectResponse

# Redirige /api/<tout> -> /<tout>
@app.api_route("/api_compat_disabled/{path:path}", methods=["GET","POST","PUT","PATCH","DELETE","OPTIONS"])
async def _api_compat(path: str, request: Request):
    return RedirectResponse(url=f"/{path}", status_code=307)

# Redirige /api/v1/<tout> -> /<tout>
@app.api_route("/api_v1_compat_disabled/{path:path}", methods=["GET","POST","PUT","PATCH","DELETE","OPTIONS"])
async def _api_v1_compat(path: str, request: Request):
    return RedirectResponse(url=f"/{path}", status_code=307)
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from sqlalchemy import create_engine, text
from decimal import Decimal
from datetime import date, datetime

def _plain(v):
    if isinstance(v, Decimal):
        try: return float(v)
        except Exception: return str(v)
    if isinstance(v, (date, datetime)):
        return v.isoformat()
    return v

def _fetch_all_sql(table: str, columns: str):
    url = os.getenv("DATABASE_URL")
    if not url:
        return []
    eng = create_engine(url, future=True)
    rows = []
    with eng.connect() as c:
        for r in c.execute(text(f"SELECT {columns} FROM {table} ORDER BY id")).mappings():
            rows.append({k: _plain(v) for k, v in r.items()})
    return rows

# ---------- ALERTS ----------
@app.get("/api/alerts", tags=["alerts"])
@app.get("/api/v1/alerts", tags=["alerts"])
def _api_alerts_list():
    try:
        items = _fetch_all_sql(
            "alerts",
            "id, product_id, kind, due_date, message, is_active, created_at, updated_at, lot_id"
        )
    except Exception:
        items = []
    return JSONResponse(content=jsonable_encoder(items or []), status_code=200)

# ---------- LOTS ----------
@app.get("/api/lots", tags=["lots"])
@app.get("/api/v1/lots", tags=["lots"])
def _api_lots_list():
    try:
        items = _fetch_all_sql(
            "lots",
            "id, product_id, quantity, unit, expiry_date, storage_location_id"
        )
    except Exception:
        items = []
    return JSONResponse(content=jsonable_encoder(items or []), status_code=200)

from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from sqlalchemy import create_engine, text
from decimal import Decimal
from datetime import date, datetime
import os

def _plain(v):
    if isinstance(v, Decimal):
        try: return float(v)
        except Exception: return str(v)
    if isinstance(v, (date, datetime)):
        return v.isoformat()
    return v

def _fetch_all_sql(table: str, columns: str):
    url = os.getenv("DATABASE_URL")
    if not url:
        return []
    eng = create_engine(url, future=True)
    rows = []
    with eng.connect() as c:
        for r in c.execute(text(f"SELECT {columns} FROM {table} ORDER BY id")).mappings():
            rows.append({k: _plain(v) for k, v in r.items()})
    return rows

# ---------- ALERTS ----------
@app.get("/api/alerts", tags=["alerts"])
@app.get("/api/v1/alerts", tags=["alerts"])
def _api_alerts_list():
    try:
        items = _fetch_all_sql(
            "alerts",
            "id, product_id, kind, due_date, message, is_active, created_at, updated_at, lot_id"
        )
    except Exception:
        items = []
    return JSONResponse(content=jsonable_encoder(items or []), status_code=200)

# ---------- LOTS ----------
@app.get("/api/lots", tags=["lots"])
@app.get("/api/v1/lots", tags=["lots"])
def _api_lots_list():
    try:
        items = _fetch_all_sql(
            "lots",
            "id, product_id, quantity, unit, expiry_date, storage_location_id"
        )
    except Exception:
        items = []
    return JSONResponse(content=jsonable_encoder(items or []), status_code=200)
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from sqlalchemy import create_engine, text
from decimal import Decimal
from datetime import date, datetime
import os

def _plain(v):
    if isinstance(v, Decimal):
        try: return float(v)
        except Exception: return str(v)
    if isinstance(v, (date, datetime)):
        return v.isoformat()
    return v

def _engine():
    url = os.getenv("DATABASE_URL")
    if not url: return None
    from sqlalchemy import create_engine
    return create_engine(url, future=True)

# ---------- STATUS ----------
@app.get("/api/status")
@app.get("/api/v1/status")
def _api_status():
    return {"api":"ok","version": os.getenv("FRESHKEEPER_VERSION","0.1.0")}

# ---------- CATEGORIES (dérivées de products.category) ----------
@app.get("/api/categories")
@app.get("/api/v1/categories")
def _api_categories():
    eng = _engine()
    items = []
    if eng is not None:
        sql = text("SELECT category, COUNT(*) AS product_count FROM products WHERE category IS NOT NULL GROUP BY category ORDER BY category")
        with eng.connect() as c:
            for r in c.execute(sql).mappings():
                items.append({"name": r["category"], "product_count": int(r["product_count"] or 0)})
    return JSONResponse(content=jsonable_encoder(items), status_code=200)

# ---------- STORAGE LOCATIONS (si la table existe : id, name) ----------
@app.get("/api/storage-locations")
@app.get("/api/v1/storage-locations")
def _api_storage_locations():
    eng = _engine()
    items = []
    if eng is not None:
        try:
            sql = text("SELECT id, name FROM storage_locations ORDER BY id")
            with eng.connect() as c:
                for r in c.execute(sql).mappings():
                    items.append({"id": r.get("id"), "name": r.get("name")})
        except Exception:
            # table absente -> liste vide
            items = []
    return JSONResponse(content=jsonable_encoder(items), status_code=200)
from fastapi import Request
from fastapi.responses import JSONResponse

# Catch-all placé en DERNIER : loggue tout chemin /api/* inconnu
@app.api_route("/api_unknown_disabled/{path:path}", methods=["GET","POST","PUT","PATCH","DELETE","OPTIONS"])
async def _api_unknown(path: str, request: Request):
    print(f"UNKNOWN /api PATH -> /api/{path}  method={request.method}")
    return JSONResponse({"detail":"Not Found","path": f"/api/{path}","method": request.method}, status_code=404)

@app.api_route("/api_v1_unknown_disabled/{path:path}", methods=["GET","POST","PUT","PATCH","DELETE","OPTIONS"])
async def _apiv1_unknown(path: str, request: Request):
    print(f"UNKNOWN /api/v1 PATH -> /api/v1/{path}  method={request.method}")
    return JSONResponse({"detail":"Not Found","path": f"/api/v1/{path}","method": request.method}, status_code=404)
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from sqlalchemy import create_engine, text
import os

@app.get("/api/missing-expiry", tags=["lots"])
@app.get("/api/v1/missing-expiry", tags=["lots"])
def _api_missing_expiry():
    url = os.getenv("DATABASE_URL")
    items = []
    if url:
        eng = create_engine(url, future=True)
        sql = text("""
            SELECT l.id AS lot_id,
                   l.product_id,
                   p.name AS product_name,
                   l.quantity,
                   l.unit,
                   l.expiry_date,
                   l.storage_location_id
            FROM lots l
            LEFT JOIN products p ON p.id = l.product_id
            WHERE l.expiry_date IS NULL
            ORDER BY l.id
        """)
        with eng.connect() as c:
            for r in c.execute(sql).mappings():
                items.append(dict(r))
    return JSONResponse(content=jsonable_encoder(items), status_code=200)
# --- ALIAS pack pour /api et /api/v1 chemins mobiles usuels ---
try:
    from freshkeeper.routers import products as _prod

    # LIST & DETAILS
    app.add_api_route("/api/products/list", _prod.list_products, methods=["GET"], tags=["products"])
    app.add_api_route("/api/v1/products/list", _prod.list_products, methods=["GET"], tags=["products"])
    app.add_api_route("/api/products/{product_id}/details", _prod.get_product, methods=["GET"], tags=["products"])
    app.add_api_route("/api/v1/products/{product_id}/details", _prod.get_product, methods=["GET"], tags=["products"])
except Exception as e:
    print("Alias products failed:", e)

from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from sqlalchemy import create_engine, text
from decimal import Decimal
from datetime import date, datetime
import os

def _plain(v):
    if isinstance(v, Decimal):
        try: return float(v)
        except Exception: return str(v)
    if isinstance(v, (date, datetime)):
        return v.isoformat()
    return v

def _sql_all(query: str):
    url = os.getenv("DATABASE_URL")
    if not url: return []
    eng = create_engine(url, future=True)
    rows=[]
    with eng.connect() as c:
        for r in c.execute(text(query)).mappings():
            rows.append({k:_plain(v) for k,v in r.items()})
    return rows

# ALERTS /active
@app.get("/api/alerts/active", tags=["alerts"])
@app.get("/api/v1/alerts/active", tags=["alerts"])
def _alerts_active_alias():
    rows = _sql_all("SELECT id, product_id, kind, due_date, message, is_active, created_at, updated_at, lot_id FROM alerts ORDER BY id")
    items = [r for r in rows if r.get("is_active")]
    return JSONResponse(content=jsonable_encoder(items or []), status_code=200)

# LOTS /grouped
@app.get("/api/lots/grouped", tags=["lots"])
@app.get("/api/v1/lots/grouped", tags=["lots"])
def _lots_grouped_alias():
    rows = _sql_all("SELECT id, product_id, quantity, unit, expiry_date, storage_location_id FROM lots ORDER BY id")
    grouped = {}
    for r in rows:
        pid = r.get("product_id")
        grouped.setdefault(pid, []).append(r)
    payload = [{"product_id": pid, "lots": lots} for pid, lots in grouped.items()]
    return JSONResponse(content=jsonable_encoder(payload or []), status_code=200)

from fastapi.routing import APIRoute
try:
    from freshkeeper.routers import products as _prod
    # priorité max : on insère au début de la table de routage
    app.router.routes.insert(0, APIRoute(path="/api/products/list", endpoint=_prod.list_products, methods=["GET"], name="products_list"))
    app.router.routes.insert(0, APIRoute(path="/api/v1/products/list", endpoint=_prod.list_products, methods=["GET"], name="products_list_v1"))
except Exception as e:
    print("Insert routes failed:", e)
from starlette.responses import Response

@app.get("/favicon.ico", include_in_schema=False)
def _favicon_blank():
    # Répond vide pour éviter le 404 automatique du navigateur
    return Response(status_code=204)
from pydantic import BaseModel
from typing import Optional
from datetime import date
from fastapi import Body
from sqlalchemy import create_engine, text
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
import os

class ProductCreate(BaseModel):
    name: str
    category: Optional[str] = None
    unit: Optional[str] = None
    quantity: Optional[float] = None
    expiry_date: Optional[date] = None
    storage_location_id: Optional[int] = None

def _ensure_engine():
    url = os.getenv("DATABASE_URL")
    if not url:
        raise RuntimeError("DATABASE_URL not set")
    return create_engine(url, future=True)

# POST /api/products (et /api/v1/products) — crée le produit, et optionnellement un lot initial
@app.post("/api/products", tags=["products"])
@app.post("/api/products/", tags=["products"])
@app.post("/api/v1/products", tags=["products"])
@app.post("/api/v1/products/", tags=["products"])
def api_products_create(payload: ProductCreate = Body(...)):
    eng = _ensure_engine()
    with eng.begin() as conn:
        # 1) Produit (recycler si même nom existe déjà)
        row = conn.execute(text("SELECT id, name, category FROM products WHERE lower(name)=lower(:n) LIMIT 1"),
                           {"n": payload.name}).first()
        if row:
            product_id = int(row[0])
            prod_name = row[1]
            prod_cat  = row[2]
        else:
            res = conn.execute(
                text("INSERT INTO products (name, category) VALUES (:name, :category) RETURNING id"),
                {"name": payload.name, "category": payload.category}
            )
            product_id = int(res.scalar_one())
            prod_name = payload.name
            prod_cat  = payload.category

        # 2) Lot initial (optionnel)
        created_lot_id = None
        if payload.quantity is not None or payload.expiry_date is not None or payload.unit is not None or payload.storage_location_id is not None:
            storage_id = payload.storage_location_id if payload.storage_location_id is not None else 1
            res = conn.execute(
                text("""
                    INSERT INTO lots (product_id, quantity, unit, expiry_date, storage_location_id)
                    VALUES (:pid, :quantity, :unit, :expiry_date, :storage_id)
                    RETURNING id
                """),
                {
                    "pid": product_id,
                    "quantity": float(payload.quantity) if payload.quantity is not None else 0.0,
                    "unit": payload.unit,
                    "expiry_date": payload.expiry_date,
                    "storage_id": storage_id
                }
            )
            created_lot_id = int(res.scalar_one())

    # Réponse simple et compatible avec l’app
    return JSONResponse(
        content=jsonable_encoder({
            "id": product_id,
            "name": prod_name,
            "category": prod_cat,
            "created_lot_id": created_lot_id
        }),
        status_code=201
    )
from fastapi import Request
from pydantic import BaseModel, ValidationError
from typing import Optional
from datetime import date
from sqlalchemy import create_engine, text
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
import os

class ProductCreateCompat(BaseModel):
    name: str
    category: Optional[str] = None
    unit: Optional[str] = None
    quantity: Optional[float] = None
    expiry_date: Optional[date] = None
    storage_location_id: Optional[int] = None

def _ensure_engine():
    url = os.getenv("DATABASE_URL")
    if not url:
        raise RuntimeError("DATABASE_URL not set")
    return create_engine(url, future=True)

async def _parse_payload_any(request: Request) -> dict:
    # Essaye JSON, sinon form, sinon vide
    try:
        data = await request.json()
        if isinstance(data, dict):
            return data
    except Exception:
        pass
    try:
        form = await request.form()
        return {k: (v if v != "" else None) for k, v in form.items()}
    except Exception:
        pass
    return {}

async def _create_product_and_optional_lot(data: dict):
    # Normalise types
    if "quantity" in data and data["quantity"] is not None:
        try:
            data["quantity"] = float(data["quantity"])
        except Exception:
            data["quantity"] = None
    if "storage_location_id" in data and data["storage_location_id"] is not None:
        try:
            data["storage_location_id"] = int(data["storage_location_id"])
        except Exception:
            data["storage_location_id"] = None

    payload = ProductCreateCompat(**data)
    eng = _ensure_engine()
    with eng.begin() as conn:
        # 1) Produit (réutilise si même nom, insensible à la casse)
        row = conn.execute(
            text("SELECT id, name, category FROM products WHERE lower(name)=lower(:n) LIMIT 1"),
            {"n": payload.name}
        ).first()
        if row:
            product_id = int(row[0])
            prod_name = row[1]
            prod_cat  = row[2]
        else:
            res = conn.execute(
                text("INSERT INTO products (name, category) VALUES (:name, :category) RETURNING id"),
                {"name": payload.name, "category": payload.category}
            )
            product_id = int(res.scalar_one())
            prod_name = payload.name
            prod_cat  = payload.category

        # 2) Lot initial (optionnel)
        created_lot_id = None
        if any(data.get(k) is not None for k in ("quantity","unit","expiry_date","storage_location_id")):
            storage_id = payload.storage_location_id if payload.storage_location_id is not None else 1
            res = conn.execute(
                text("""
                    INSERT INTO lots (product_id, quantity, unit, expiry_date, storage_location_id)
                    VALUES (:pid, :quantity, :unit, :expiry_date, :storage_id)
                    RETURNING id
                """),
                {
                    "pid": product_id,
                    "quantity": float(payload.quantity) if payload.quantity is not None else 0.0,
                    "unit": payload.unit,
                    "expiry_date": payload.expiry_date,
                    "storage_id": storage_id
                }
            )
            created_lot_id = int(res.scalar_one())

    return {
        "id": product_id,
        "name": prod_name,
        "category": prod_cat,
        "created_lot_id": created_lot_id
    }

# Nouveaux alias très permissifs (JSON OU FORM) :
@app.post("/api/products/create", tags=["products"])
@app.post("/api/products/create/", tags=["products"])
@app.post("/api/v1/products/create", tags=["products"])
@app.post("/api/v1/products/create/", tags=["products"])
async def api_products_create_compat(request: Request):
    data = await _parse_payload_any(request)
    try:
        result = await _create_product_and_optional_lot(data)
        return JSONResponse(content=jsonable_encoder(result), status_code=201)
    except ValidationError as ve:
        return JSONResponse(content={"detail":"Invalid payload","errors": jsonable_encoder(ve.errors())}, status_code=422)
    except Exception as e:
        return JSONResponse(content={"detail":"Server error","error": str(e)}, status_code=500)
from urllib.parse import parse_qs

async def _parse_payload_any(request: Request) -> dict:
    ctype = (request.headers.get("content-type") or "").lower()

    # JSON direct
    if "application/json" in ctype:
        try:
            data = await request.json()
            if isinstance(data, dict):
                return data
        except Exception:
            pass

    # x-www-form-urlencoded (sans python-multipart)
    if "application/x-www-form-urlencoded" in ctype:
        try:
            raw = await request.body()
            q = parse_qs(raw.decode("utf-8"), keep_blank_values=True)
            return {k: (v[0] if isinstance(v, list) and v else None) for k, v in q.items()}
        except Exception:
            pass

    # multipart/form-data (si python-multipart dispo)
    try:
        form = await request.form()
        return {k: (v if v != "" else None) for k, v in form.items()}
    except Exception:
        pass

    # dernier recours: tenter un parse url-encodé sans content-type fiable
    try:
        raw = await request.body()
        if raw:
            q = parse_qs(raw.decode("utf-8"), keep_blank_values=True)
            if q:
                return {k: (v[0] if isinstance(v, list) and v else None) for k, v in q.items()}
    except Exception:
        pass

    return {}

# Alias POST singuliers (au cas où l'app utilise /api/product)
@app.post("/api/product", tags=["products"])
@app.post("/api/product/", tags=["products"])
@app.post("/api/v1/product", tags=["products"])
@app.post("/api/v1/product/", tags=["products"])
async def api_product_create_singular(request: Request):
    data = await _parse_payload_any(request)
    try:
        result = await _create_product_and_optional_lot(data)
        return JSONResponse(content=jsonable_encoder(result), status_code=201)
    except ValidationError as ve:
        return JSONResponse(content={"detail":"Invalid payload","errors": jsonable_encoder(ve.errors())}, status_code=422)
    except Exception as e:
        return JSONResponse(content={"detail":"Server error","error": str(e)}, status_code=500)
# ===== Pack d’alias pour couvrir les variantes que les apps utilisent souvent =====
from fastapi.responses import JSONResponse
from fastapi.encoders import jsonable_encoder
from sqlalchemy import create_engine, text
from decimal import Decimal
from datetime import date, datetime
import os

def _plain(v):
    if isinstance(v, Decimal):
        try: return float(v)
        except Exception: return str(v)
    if isinstance(v, (date, datetime)):
        return v.isoformat()
    return v

def _sql_all(q: str):
    url = os.getenv("DATABASE_URL")
    if not url: return []
    eng = create_engine(url, future=True)
    rows=[]
    with eng.connect() as c:
        for r in c.execute(text(q)).mappings():
            rows.append({k:_plain(v) for k,v in r.items()})
    return rows

# --- INVENTORY (alias vers lots groupés)
@app.get("/api/inventory", tags=["inventory"])
@app.get("/api/inventory/", tags=["inventory"])
@app.get("/api/v1/inventory", tags=["inventory"])
@app.get("/api/v1/inventory/", tags=["inventory"])
def api_inventory_alias():
    rows = _sql_all("SELECT id, product_id, quantity, unit, expiry_date, storage_location_id FROM lots ORDER BY id")
    grouped = {}
    for r in rows:
        pid = r.get("product_id")
        grouped.setdefault(pid, []).append(r)
    payload = [{"product_id": pid, "lots": lots} for pid, lots in grouped.items()]
    return JSONResponse(content=jsonable_encoder(payload or []), status_code=200)

# --- CATEGORIES (avec variantes /, /all, v1)
@app.get("/api/categories", tags=["categories"])
@app.get("/api/categories/", tags=["categories"])
@app.get("/api/categories/all", tags=["categories"])
@app.get("/api/v1/categories", tags=["categories"])
@app.get("/api/v1/categories/", tags=["categories"])
@app.get("/api/v1/categories/all", tags=["categories"])
def api_categories_alias():
    rows = _sql_all("SELECT category FROM products WHERE category IS NOT NULL")
    # comptage simple
    counts = {}
    for r in rows:
        c = r.get("category")
        if c:
            counts[c] = counts.get(c, 0) + 1
    payload = [{"name": name, "product_count": count} for name, count in sorted(counts.items())]
    return JSONResponse(content=jsonable_encoder(payload), status_code=200)

# --- STORAGE LOCATIONS (avec variantes /, v1, et alias '/storage')
@app.get("/api/storage-locations", tags=["storage"])
@app.get("/api/storage-locations/", tags=["storage"])
@app.get("/api/v1/storage-locations", tags=["storage"])
@app.get("/api/v1/storage-locations/", tags=["storage"])
@app.get("/api/storage", tags=["storage"])
@app.get("/api/storage/", tags=["storage"])
@app.get("/api/v1/storage", tags=["storage"])
@app.get("/api/v1/storage/", tags=["storage"])
def api_storage_locations_alias():
    rows = _sql_all("SELECT id, name FROM storage_locations ORDER BY id")
    return JSONResponse(content=jsonable_encoder(rows or []), status_code=200)

# --- PRODUCTS LIST (sans /list, pour apps qui appellent juste /products)
try:
    from freshkeeper.routers import products as _prod
    # formes sans /list
    app.add_api_route("/api/products", _prod.list_products, methods=["GET"], tags=["products"])
    app.add_api_route("/api/products/", _prod.list_products, methods=["GET"], tags=["products"])
    app.add_api_route("/api/v1/products", _prod.list_products, methods=["GET"], tags=["products"])
    app.add_api_route("/api/v1/products/", _prod.list_products, methods=["GET"], tags=["products"])
except Exception as e:
    print("Alias products list (sans /list) non ajoutés:", e)
# ====== DEBUG SQL: CONNECTIVITÉ + TABLES + échantillons ======
from fastapi.responses import JSONResponse
from sqlalchemy import create_engine, text
import os

def _eng():
    url = os.getenv("DATABASE_URL")
    if not url:
        return None, "DATABASE_URL not set"
    try:
        eng = create_engine(url, future=True)
        return eng, None
    except Exception as e:
        return None, str(e)

def _table_count(conn, table):
    try:
        r = conn.execute(text(f"SELECT COUNT(*) AS c FROM {table}")).scalar_one()
        return {"exists": True, "count": int(r)}
    except Exception as e:
        return {"exists": False, "error": str(e)}

def _sample_rows(conn, table, limit=5):
    try:
        rows = [dict(r) for r in conn.execute(text(f"SELECT * FROM {table} ORDER BY 1 LIMIT :n"), {"n": limit}).mappings()]
        return {"ok": True, "rows": rows}
    except Exception as e:
        return {"ok": False, "error": str(e)}

@app.get("/debug/db")
def debug_db():
    eng, err = _eng()
    if err:
        return JSONResponse({"ok": False, "error": err}, status_code=500)
    try:
        with eng.connect() as c:
            # ping
            c.execute(text("SELECT 1"))
            info = {
                "ok": True,
                "url": os.getenv("DATABASE_URL"),
                "tables": {
                    "products": _table_count(c, "products"),
                    "lots": _table_count(c, "lots"),
                    "alerts": _table_count(c, "alerts"),
                    "storage_locations": _table_count(c, "storage_locations"),
                },
            }
            # quelques métadonnées si dispo
            try:
                v = c.execute(text("SHOW server_version")).scalar_one_or_none()
                info["server_version"] = v
            except Exception:
                pass
            return info
    except Exception as e:
        return JSONResponse({"ok": False, "error": str(e)}, status_code=500)

@app.get("/debug/tables")
def debug_tables():
    eng, err = _eng()
    if err:
        return JSONResponse({"ok": False, "error": err}, status_code=500)
    with eng.connect() as c:
        tables = [dict(r) for r in c.execute(text("""
            SELECT table_schema, table_name
            FROM information_schema.tables
            WHERE table_schema='public'
            ORDER BY table_name
        """)).mappings()]
        cols = [dict(r) for r in c.execute(text("""
            SELECT table_name, column_name, data_type, is_nullable
            FROM information_schema.columns
            WHERE table_schema='public'
            ORDER BY table_name, ordinal_position
        """)).mappings()]
        return {"ok": True, "tables": tables, "columns": cols}

@app.get("/debug/samples")
def debug_samples():
    eng, err = _eng()
    if err:
        return JSONResponse({"ok": False, "error": err}, status_code=500)
    with eng.connect() as c:
        return {
            "ok": True,
            "products": _sample_rows(c, "products"),
            "lots": _sample_rows(c, "lots"),
            "alerts": _sample_rows(c, "alerts"),
            "storage_locations": _sample_rows(c, "storage_locations"),
        }
# ====== FIN DEBUG ======
# ====== ALIASES & CREATE ENDPOINTS pour compat app mobile ======
from fastapi import Request
from fastapi.responses import JSONResponse
from sqlalchemy import create_engine, text
import os

def _eng():
    url = os.getenv("DATABASE_URL")
    if not url:
        raise RuntimeError("DATABASE_URL not set")
    return create_engine(url, future=True)

async def _payload(request: Request):
    ctype = (request.headers.get("content-type") or "").lower()
    try:
        if "application/json" in ctype:
            return await request.json()
        if "application/x-www-form-urlencoded" in ctype or "multipart/form-data" in ctype:
            form = await request.form()
            return dict(form)
        # fallback: tente JSON
        return await request.json()
    except Exception:
        return {}

# -------- Storage locations (underscores & tirets, avec/sans /api) --------
def _list_storage_locations():
    eng = _eng()
    with eng.connect() as c:
        rows = [dict(r) for r in c.execute(text(
            "SELECT id, name, kind, parent_id FROM storage_locations ORDER BY id"
        )).mappings()]
        return rows

for _path in [
    "/storage-locations", "/storage-locations/",
    "/storage_locations", "/storage_locations/",
    "/api/storage-locations", "/api/storage-locations/",
    "/api/storage_locations", "/api/storage_locations/",
    "/api/v1/storage-locations", "/api/v1/storage-locations/",
    "/api/v1/storage_locations", "/api/v1/storage_locations/",
]:
    app.add_api_route(_path, lambda: _list_storage_locations(), methods=["GET"], tags=["storage"])

# -------- Products: POST (JSON ou FORM) + alias multiples --------
@app.post("/products")
@app.post("/products/")
@app.post("/api/products")
@app.post("/api/products/")
@app.post("/api/v1/products")
@app.post("/api/v1/products/")
async def _create_product(request: Request):
    p = await _payload(request)
    name = (p.get("name") or "").strip()
    if not name:
        return JSONResponse({"detail":"Invalid payload","errors":[{"loc":["name"],"msg":"Field required"}]}, status_code=400)
    category = (p.get("category") or None)
    unit = (p.get("unit") or None)
    # Quelques apps envoient aussi quantity/expiry_date (optionnel)
    try:
        quantity = float(p.get("quantity")) if p.get("quantity") not in (None, "") else 0
    except Exception:
        quantity = 0
    expiry_date = p.get("expiry_date") or None
    # 'location' est NOT NULL dans ta table -> valeur par défaut raisonnable
    location = (p.get("location") or "fridge")

    eng = _eng()
    with eng.begin() as c:
        new_id = c.execute(text("""
            INSERT INTO products (name, category, unit, quantity, expiry_date, location, is_active)
            VALUES (:name, :category, :unit, :quantity, :expiry_date, :location, TRUE)
            RETURNING id
        """), {
            "name": name, "category": category, "unit": unit,
            "quantity": quantity, "expiry_date": expiry_date, "location": location
        }).scalar_one()
        row = c.execute(text("""
            SELECT id, name, category, unit, quantity, expiry_date
            FROM products WHERE id=:id
        """), {"id": new_id}).mappings().one()
    

# -------- Lots: GET existe déjà chez toi; on ajoute POST attendu par l'app --------
# -------- Lots: POST (JSON ou FORM) -----------------------------------------------
from sqlalchemy.exc import SQLAlchemyError, IntegrityError, ProgrammingError
from fastapi.encoders import jsonable_encoder
from decimal import Decimal

@app.post("/lots")
@app.post("/lots/")
@app.post("/api/lots")
@app.post("/api/lots/")
@app.post("/api/v1/lots")
@app.post("/api/v1/lots/")
async def _create_lot(request: Request):
    p = await _payload(request)

    def _int(v):
        try: return int(v)
        except: return None

    def _float(v):
        try: return float(v)
        except: return None

    product_id = _int(p.get("product_id"))
    storage_location_id = _int(p.get("storage_location_id"))
    quantity = _float(p.get("quantity"))
    unit = p.get("unit") or None
    expiry_date = p.get("expiry_date") or None  # "YYYY-MM-DD" ou None
    unit_norm = (unit or "").strip().lower()

    missing = []
    if not product_id: missing.append("product_id")
    if quantity is None: missing.append("quantity")
    if not storage_location_id: missing.append("storage_location_id")
    if missing:
        return JSONResponse({"detail":"Invalid payload","errors":[{"loc":missing,"msg":"Field(s) required"}]}, status_code=400)

    eng = _eng()
    with eng.begin() as c:
        try:
            # 1) UPSERT par colonnes (plus portable que par nom de contrainte)
            new_id = c.execute(
                text("""
                    INSERT INTO lots (product_id, quantity, unit, expiry_date, storage_location_id, unit_norm)
                    VALUES (:product_id, :quantity, :unit, :expiry_date, :storage_location_id, :unit_norm)
                    ON CONFLICT (product_id, expiry_date, storage_location_id, unit_norm)
                    DO UPDATE SET quantity = lots.quantity + EXCLUDED.quantity,
                                  updated_at = NOW()
                    RETURNING id
                """),
                {
                    "product_id": product_id,
                    "quantity": quantity,
                    "unit": unit,
                    "expiry_date": expiry_date,
                    "storage_location_id": storage_location_id,
                    "unit_norm": unit_norm,
                }
            ).scalar_one()
        except (ProgrammingError, IntegrityError, SQLAlchemyError):
            # 2) Fallback universel : UPDATE si ligne existe, sinon INSERT simple
            upd = c.execute(
                text("""
                    UPDATE lots
                       SET quantity = quantity + :quantity,
                           updated_at = NOW()
                     WHERE product_id = :product_id
                       AND storage_location_id = :storage_location_id
                       AND ((expiry_date IS NULL AND :expiry_date IS NULL) OR (expiry_date = :expiry_date))
                       AND COALESCE(unit_norm,'') = COALESCE(:unit_norm,'')
                    RETURNING id
                """),
                {
                    "product_id": product_id,
                    "quantity": quantity,
                    "expiry_date": expiry_date,
                    "storage_location_id": storage_location_id,
                    "unit_norm": unit_norm,
                }
            ).scalar_one_or_none()

            if upd is None:
                new_id = c.execute(
                    text("""
                        INSERT INTO lots (product_id, quantity, unit, expiry_date, storage_location_id, unit_norm)
                        VALUES (:product_id, :quantity, :unit, :expiry_date, :storage_location_id, :unit_norm)
                        RETURNING id
                    """),
                    {
                        "product_id": product_id,
                        "quantity": quantity,
                        "unit": unit,
                        "expiry_date": expiry_date,
                        "storage_location_id": storage_location_id,
                        "unit_norm": unit_norm,
                    }
                ).scalar_one()
            else:
                new_id = upd

        row = c.execute(
            text("""
                SELECT id, product_id,
                       CAST(quantity AS double precision) AS quantity,
                       unit, expiry_date, storage_location_id
                FROM lots WHERE id=:id
            """),
            {"id": new_id}
        ).mappings().one()

    return JSONResponse(jsonable_encoder(dict(row), custom_encoder={Decimal: float}), status_code=201)
