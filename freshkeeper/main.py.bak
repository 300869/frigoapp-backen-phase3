from freshkeeper.api.suggest import router as suggest_router
from src.api.maintenance import router as maintenance_router
from src.api.inventory import router as inventory_router
from fastapi import FastAPI, HTTPException, APIRouter
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import Optional, List, Literal, Dict, Any
from enum import Enum
from datetime import date, datetime, timedelta
import os
from routers.lots import router as lots_router
from routers.storage_locations import router as storage_router
from routers.status import router as status_router
from routers.maintenance import router as admin_router
from freshkeeper.routers.products import router as products_router
from routers.alerts import router as alerts_router
from freshkeeper.routers.products import router as products_router
# freshkeeper/main.py
from fastapi import FastAPI
from freshkeeper.routers import suggest   # ✅ import du routeur
# freshkeeper/main.py (ou équivalent)

app = FastAPI(title="FreshKeeper API",
    generate_unique_id_function=lambda route: f"{route.name}_{route.path.replace('/', '_')}")
# ... tes autres app.include_router(...)
# ✅ branchement
# branchement du router

# si products.py est à la racine du projet
from freshkeeper.routers.products import router as products_router
# (sinon, si tu as un dossier "routers/", utilise:)
from freshkeeper.routers.products import router as products_router
# -------------------------------------------------
# App & CORS
# -------------------------------------------------
APP_NAME = os.getenv("FRESHKEEPER_APP_NAME", "FreshKeeper API")
APP_VERSION = os.getenv("FRESHKEEPER_VERSION", "0.1.0")
ENV = os.getenv("FRESHKEEPER_ENV", "prod").lower()

app = FastAPI(title="FreshKeeper API",
    generate_unique_id_function=lambda route: f"{route.name}_{route.path.replace('/', '_')}")

app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("CORS_ALLOW_ORIGINS", "*").split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
app = FastAPI(title="FreshKeeper API",
    generate_unique_id_function=lambda route: f"{route.name}_{route.path.replace('/', '_')}")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # élargir si tu veux resserrer plus tard
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
app.include_router(storage_router)
app.include_router(lots_router)
app.include_router(status_router)
app.include_router(admin_router)
app.include_router(alerts_router)
#--------Ajout de produit-----------
# --- PRODUCTS endpoints (liste + création) ---
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy import text

# ⚠️ importe ta SessionLocal existante (c'est la même que pour les autres routes)
from database import SessionLocal

products_router = APIRouter(prefix="/products", tags=["products"])

class ProductIn(BaseModel):
    name: str
    unit: Optional[str] = None
    category: Optional[str] = None

class ProductOut(ProductIn):
    id: int

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@products_router.get("", response_model=List[ProductOut])
def list_products(q: Optional[str] = Query(None, min_length=1), db: Session = Depends(get_db)):
    if q:
        rows = db.execute(text("""
            SELECT id, name, unit, category
            FROM products
            WHERE name ILIKE :q
            ORDER BY name
            LIMIT 200
        """), {"q": f"%{q}%"}).mappings().all()
    else:
        rows = db.execute(text("""
            SELECT id, name, unit, category
            FROM products
            ORDER BY name
            LIMIT 200
        """)).mappings().all()
    return rows

@products_router.post("", response_model=ProductOut, status_code=201)
def create_product(p: ProductIn, db: Session = Depends(get_db)):
    try:
        row = db.execute(text("""
            INSERT INTO products (name, unit, category)
            VALUES (:name, :unit, :category)
            RETURNING id, name, unit, category
        """), p.dict()).mappings().first()
        db.commit()
        return row
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))

# Enregistrer le router
# -------------------------------------------------
# Utils
# -------------------------------------------------
def today_str() -> str:
    return date.today().isoformat()

def normalize_name(name: Optional[str]) -> str:
    """
    Robust singularization for FR-first data, avoiding 'Pommes' -> 'Pomm' bug.
    Rules:
      - Trim/normalize spaces, lowercase -> capitalize.
      - FR: 'eaux' -> 'eau', 'aux' -> 'al' (chevaux -> cheval).
      - EN common: 'ies' -> 'y'; 'oes/xes/ches/shes' -> drop 'es'.
      - General: drop a final single 's' (but keep 'ss').
    """
    n = (name or "").strip().lower()
    if not n:
        return ""
    n = " ".join(n.split())  # collapse multiple spaces

    # French irregulars
    if n.endswith("eaux"):            # ex: 'eaux' -> 'eau'
        n = n[:-1]
    elif n.endswith("aux") and len(n) > 3:   # chevaux -> cheval, journaux -> journal
        n = n[:-3] + "al"
    else:
        # English common plurals
        if n.endswith("ies") and len(n) > 3:             # batteries -> battery
            n = n[:-3] + "y"
        elif n.endswith(("oes", "xes", "ches", "shes")) and len(n) > 4:
            n = n[:-2]                                   # tomatoes -> tomato, boxes -> box
        # General FR: drop single trailing 's' (but not 'ss')
        elif n.endswith("s") and not n.endswith("ss"):
            n = n[:-1]

    return n.capitalize()
def _days_to_expiry(expiry: Optional[str]) -> Optional[int]:
    if not expiry:
        return None
    try:
        d = datetime.strptime(expiry, "%Y-%m-%d").date()
        return (d - date.today()).days
    except Exception:
        return None

# Color thresholds (modifiable via COLOR_SETTINGS if needed)
COLOR_SETTINGS = {
    "red_max": 2,     # <= red_max  -> rouge
    "yellow_max": 7,  # <= yellow_max (and > red_max) -> jaune
}

def _color_for_days(days: Optional[int]) -> str:
    if days is None:
        return "inconnu"
    red_max = int(COLOR_SETTINGS.get("red_max", 2))
    yellow_max = int(COLOR_SETTINGS.get("yellow_max", 7))
    if days <= red_max:
        return "rouge"
    if days <= yellow_max:
        return "jaune"
    return "vert"

# -------------------------------------------------
# Models
# -------------------------------------------------
class ProductIn(BaseModel):
    name: str

class ProductOut(BaseModel):
    id: int
    name: str

class ProductUpdateIn(BaseModel):
    name: str

class AlertKind(str, Enum):
    EXPIRED = "EXPIRED"
    SOON = "SOON"
    OUT_OF_STOCK = "OUT_OF_STOCK"
    CRITICAL = "CRITICAL"

class AlertOut(BaseModel):
    id: int
    product_id: int
    product_name: Optional[str] = None
    kind: AlertKind
    due_date: Optional[str] = None

class LotIn(BaseModel):
    name: Optional[str] = None
    product_id: Optional[int] = None
    quantity: float = 1
    unit: str = "pcs"
    purchased_at: Optional[str] = None  # YYYY-MM-DD
    shelf_life_days: Optional[int] = 4
    expiry_date: Optional[str] = None
    location: Optional[str] = None

class LotConsumeIn(BaseModel):
    quantity: float

class LotMoveIn(BaseModel):
    location: str

class LotOut(BaseModel):
    id: int
    product_id: int
    product_name: str
    quantity: float
    consumed: float
    unit: str
    purchased_at: Optional[str] = None
    shelf_life_days: Optional[int] = None
    expiry_date: Optional[str] = None
    location: Optional[str] = None

class LotOutExtended(LotOut):
    delai_restant: Optional[int] = None  # computed

ShoppingStatus = Literal["open", "pending", "done"]

class ShoppingItemIn(BaseModel):
    name: str
    quantity: float = 1
    unit: str = "pcs"

class ShoppingItemOut(BaseModel):
    id: int
    product_id: Optional[int] = None
    product_name: str
    quantity: float
    unit: str
    status: ShoppingStatus
    created_at: str

class InventoryItemOut(BaseModel):
    product_id: int
    product_name: str
    location: str
    total: float
    unit: str

# For /shopping_list/{sid}/classify (single item -> lot)
class ShoppingClassifyIn(BaseModel):
    location: str  # FRIDGE, FREEZER, PANTRY1..5

# Admin rename model
class RenameProductIn(BaseModel):
    old_name: str
    new_name: str

# -------------------------------------------------
# In-memory DB (dev/demo)
# -------------------------------------------------
_PRODUCTS_DB: List[ProductOut] = []
_LOTS_DB: List[LotOut] = []
_ALERTS_DB: List[AlertOut] = []
_SHOPPING_DB: List[ShoppingItemOut] = []
_HISTORY_DB: List[Dict[str, Any]] = []  # simple historique
_AA_LIST: Dict[str, float] = {}         # liste AA modifiable par l'utilisateur

_NEXT_IDS = {"product": 1, "lot": 1, "alert": 1, "shopping": 1, "history": 1}
_STORAGE_LOCATIONS = ["FRIDGE", "FREEZER", "PANTRY1", "PANTRY2", "PANTRY3", "PANTRY4", "PANTRY5"]

def _get_or_create_product(name: str) -> ProductOut:
    global _NEXT_IDS
    norm = normalize_name(name)
    for p in _PRODUCTS_DB:
        if normalize_name(p.name) == norm:
            return p
    p = ProductOut(id=_NEXT_IDS["product"], name=norm)
    _NEXT_IDS["product"] += 1
    _PRODUCTS_DB.append(p)
    return p

def _add_lot(product: ProductOut, qty: float, unit: str, purchased: Optional[str], shelf: Optional[int], location: Optional[str], expiry_date: Optional[str]=None) -> LotOut:
    global _NEXT_IDS
    if not purchased:
        purchased = today_str()
    exp = expiry_date
    if exp is None and shelf is not None:
        try:
            d = datetime.strptime(purchased, "%Y-%m-%d").date()
            exp = (d + timedelta(days=shelf)).isoformat()
        except Exception:
            exp = None
    lot = LotOut(
        id=_NEXT_IDS["lot"],
        product_id=product.id,
        product_name=product.name,
        quantity=qty,
        consumed=0,
        unit=unit or "pcs",
        purchased_at=purchased,
        shelf_life_days=shelf,
        expiry_date=exp,
        location=location
    )
    _NEXT_IDS["lot"] += 1
    _LOTS_DB.append(lot)
    return lot

def _add_shopping(name: str, qty: float, unit: str, status: ShoppingStatus) -> ShoppingItemOut:
    global _NEXT_IDS
    item = ShoppingItemOut(
        id=_NEXT_IDS["shopping"],
        product_id=None,
        product_name=normalize_name(name),
        quantity=qty,
        unit=unit or "pcs",
        status=status,
        created_at=datetime.utcnow().isoformat()
    )
    _NEXT_IDS["shopping"] += 1
    _SHOPPING_DB.append(item)
    return item

def _move_expired_to_history() -> int:
    global _LOTS_DB, _HISTORY_DB, _NEXT_IDS, _ALERTS_DB
    kept = []
    moved = 0
    for l in _LOTS_DB:
        days = _days_to_expiry(l.expiry_date)
        if days is not None and days < 0:
            _HISTORY_DB.append({
                "id": _NEXT_IDS["history"],
                "product_id": l.product_id,
                "product_name": l.product_name,
                "quantity": l.quantity,
                "unit": l.unit,
                "expired_at": l.expiry_date,
                "moved_at": today_str(),
                "location": l.location,
            })
            _NEXT_IDS["history"] += 1
            _ALERTS_DB.append(AlertOut(
                id=_NEXT_IDS["alert"],
                product_id=l.product_id,
                product_name=l.product_name,
                kind=AlertKind.EXPIRED,
                due_date=l.expiry_date
            ))
            _NEXT_IDS["alert"] += 1
            moved += 1
        else:
            kept.append(l)
    _LOTS_DB = kept
    return moved

def _refresh_alerts() -> int:
    global _ALERTS_DB, _NEXT_IDS
    count = 0
    for l in _LOTS_DB:
        d = _days_to_expiry(l.expiry_date)
        if d is None:
            continue
        if d <= 3:
            _ALERTS_DB.append(AlertOut(
                id=_NEXT_IDS["alert"], product_id=l.product_id, product_name=l.product_name,
                kind=AlertKind.CRITICAL, due_date=l.expiry_date
            ))
            _NEXT_IDS["alert"] += 1
            count += 1
        elif d <= 10:
            _ALERTS_DB.append(AlertOut(
                id=_NEXT_IDS["alert"], product_id=l.product_id, product_name=l.product_name,
                kind=AlertKind.SOON, due_date=l.expiry_date
            ))
            _NEXT_IDS["alert"] += 1
            count += 1
    return count

# Seed dev
def _seed_if_empty():
    global _ALERTS_DB, _NEXT_IDS
    if not _PRODUCTS_DB:
        p1 = _get_or_create_product("Banane")
        p2 = _get_or_create_product("Pomme")
        _add_lot(p1, 6, "pcs", today_str(), 4, "PANTRY1")
        _add_lot(p2, 4, "pcs", today_str(), 7, "FRIDGE")
        _ALERTS_DB.append(AlertOut(
            id=_NEXT_IDS["alert"], product_id=p1.id, product_name=p1.name,
            kind=AlertKind.SOON, due_date=(date.today()+timedelta(days=2)).isoformat()
        ))
        _NEXT_IDS["alert"] += 1
        _add_shopping("Riz", 1, "kg", "open")

@app.on_event("startup")
def _on_startup():
    if ENV == "dev":
        _seed_if_empty()

# -------------------------------------------------
# Health
# -------------------------------------------------
@app.get("/")
def root():
    return {"message": f"{APP_NAME} is running", "version": APP_VERSION}

@app.get("/health")
def health():
    return {"status": "ok"}

# -------------------------------------------------
# Admin: rename product everywhere
# -------------------------------------------------
@app.post("/admin/rename-product")
def admin_rename_product(body: RenameProductIn):
    old_norm = (body.old_name or "").strip()
    new_norm = (body.new_name or "").strip()
    if not old_norm or not new_norm:
        raise HTTPException(status_code=400, detail="old_name et new_name sont requis.")

    changed_lots = 0
    for l in _LOTS_DB:
        if (l.product_name or "").strip() == old_norm:
            l.product_name = new_norm
            changed_lots += 1

    changed_alerts = 0
    for a in _ALERTS_DB:
        if (a.product_name or "").strip() == old_norm:
            a.product_name = new_norm
            changed_alerts += 1

    # Also rename in PRODUCTS_DB
    for p in _PRODUCTS_DB:
        if (p.name or "").strip() == old_norm:
            p.name = new_norm

    return {
        "ok": True,
        "renamed_from": old_norm,
        "renamed_to": new_norm,
        "lots_updated": changed_lots,
        "alerts_updated": changed_alerts,
    }

# -------------------------------------------------
# Products
# -------------------------------------------------
@app.get("/products", response_model=List[ProductOut])
def list_products():
    return _PRODUCTS_DB

@app.post("/products", response_model=ProductOut)
def create_product(data: ProductIn):
    return _get_or_create_product(data.name)

@app.put("/products/{pid}", response_model=ProductOut)
def rename_product(pid: int, data: ProductUpdateIn):
    for p in _PRODUCTS_DB:
        if p.id == pid:
            p.name = normalize_name(data.name)
            return p
    raise HTTPException(404, "Product not found")

@app.delete("/products/{pid}")
def delete_product(pid: int):
    global _PRODUCTS_DB, _LOTS_DB, _SHOPPING_DB
    if not any(p.id == pid for p in _PRODUCTS_DB):
        raise HTTPException(404, "Product not found")
    _PRODUCTS_DB = [p for p in _PRODUCTS_DB if p.id != pid]
    _LOTS_DB = [l for l in _LOTS_DB if l.product_id != pid]
    _SHOPPING_DB = [s for s in _SHOPPING_DB if s.product_id != pid]
    return {"ok": True}

# -------------------------------------------------
# Lots grouped
# -------------------------------------------------
@app.get("/lots/grouped")
def list_grouped_lots():
    """
    Regroupe les lots par produit et trie chaque sous-lot par délai restant (petit -> grand).
    Renvoie: { "lots_grouped": { product_name: [ {id, qty, unit, expiry_date, delai_restant, color, location}, ... ] } }
    """
    groups: Dict[str, list] = {}
    for l in _LOTS_DB:
        days = _days_to_expiry(l.expiry_date)
        item = {
            "id": l.id,
            "qty": float(l.quantity or 0),
            "unit": l.unit,
            "expiry_date": l.expiry_date,
            "delai_restant": days,
            "color": _color_for_days(days),
            "location": l.location,
        }
        groups.setdefault(l.product_name, []).append(item)

    for k, arr in groups.items():
        arr.sort(key=lambda x: (999999 if x["delai_restant"] is None else x["delai_restant"]))

    return {"lots_grouped": groups}

# -------------------------------------------------
# Inventory (by location + search)
# -------------------------------------------------
@app.get("/inventory", response_model=List[InventoryItemOut])
def inventory(location: Optional[str] = None, q: Optional[str] = None):
    if location and location not in _STORAGE_LOCATIONS:
        raise HTTPException(400, "Invalid location")
    qn = normalize_name(q or "")
    agg: Dict[tuple, float] = {}
    for l in _LOTS_DB:
        rem = max(0, (l.quantity or 0) - (l.consumed or 0))
        if rem <= 0:
            continue
        loc = l.location or "PANTRY1"
        if location and loc != location:
            continue
        if q and qn not in normalize_name(l.product_name):
            continue
        key = (l.product_id, l.product_name, loc, l.unit or "pcs")
        agg[key] = agg.get(key, 0) + rem
    out: List[InventoryItemOut] = []
    for (pid, pname, loc, unit), total in agg.items():
        out.append(InventoryItemOut(
            product_id=pid, product_name=pname, location=loc, total=total, unit=unit
        ))
    out.sort(key=lambda x: (x.location, x.product_name))
    return out

# -------------------------------------------------
# Alerts
# -------------------------------------------------
@app.get("/alerts", response_model=List[AlertOut])
def list_alerts():
    return _ALERTS_DB

@app.post("/alerts/{alert_id}/ack")
def ack_alert(alert_id: int):
    global _ALERTS_DB
    for i, a in enumerate(_ALERTS_DB):
        if a.id == alert_id:
            del _ALERTS_DB[i]
            return {"ok": True}
    raise HTTPException(404, "Alert not found")

# -------------------------------------------------
# Storage locations
# -------------------------------------------------
@app.get("/storage_locations", response_model=List[str])
def list_storage_locations():
    return _STORAGE_LOCATIONS

# -------------------------------------------------
# Shopping list (simple workflow)
# -------------------------------------------------
@app.get("/shopping_list", response_model=List[ShoppingItemOut])
def get_shopping_list(status: Optional[ShoppingStatus] = None):
    if status:
        return [s for s in _SHOPPING_DB if s.status == status]
    return _SHOPPING_DB

@app.post("/shopping_list", response_model=ShoppingItemOut)
def add_shopping_item(data: ShoppingItemIn):
    norm = normalize_name(data.name)
    for s in _SHOPPING_DB:
        if s.status == "open" and normalize_name(s.product_name) == norm and s.unit == (data.unit or "pcs"):
            s.quantity += data.quantity or 1
            return s
    return _add_shopping(norm, data.quantity or 1, data.unit or "pcs", "open")

@app.post("/shopping_list/{sid}/buy", response_model=ShoppingItemOut)
def buy_shopping_item(sid: int):
    for s in _SHOPPING_DB:
        if s.id == sid:
            s.status = "pending"
            return s
    raise HTTPException(404, "Shopping item not found")

@app.post("/shopping_list/{sid}/delete")
def delete_shopping_item(sid: int):
    global _SHOPPING_DB
    for i, s in enumerate(_SHOPPING_DB):
        if s.id == sid:
            del _SHOPPING_DB[i]
            return {"ok": True}
    raise HTTPException(404, "Shopping item not found")

@app.post("/shopping_list/{sid}/classify", response_model=LotOut)
def classify_shopping_item(sid: int, data: ShoppingClassifyIn):
    if data.location not in _STORAGE_LOCATIONS:
        raise HTTPException(400, "Invalid location")
    for i, s in enumerate(_SHOPPING_DB):
        if s.id == sid:
            product = _get_or_create_product(s.product_name)
            lot = _add_lot(product, s.quantity, s.unit, today_str(), 4, data.location)
            s.status = "done"
            return lot
    raise HTTPException(404, "Shopping item not found")

# -------------------------------------------------
# Suggestions & recommendations
# -------------------------------------------------
@app.get("/suggested_purchases", response_model=List[ShoppingItemOut])
def suggested_purchases(threshold: int = 0):
    suggestions = []
    by_product = {}
    for l in _LOTS_DB:
        by_product.setdefault(l.product_id, 0)
        by_product[l.product_id] += max(0, l.quantity - l.consumed)
    for p in _PRODUCTS_DB:
        remaining = by_product.get(p.id, 0)
        if remaining <= threshold:
            suggestions.append(ShoppingItemOut(
                id=0, product_id=p.id, product_name=p.name, quantity=1, unit="pcs",
                status="open", created_at=datetime.utcnow().isoformat()
            ))
    return suggestions

@app.get("/recommendations", response_model=List[ShoppingItemOut])
def recommendations(days: int = 60):
    cutoff = date.today() - timedelta(days=days)
    counts: Dict[str, float] = {}
    for l in _LOTS_DB:
        try:
            d = datetime.strptime(l.purchased_at or today_str(), "%Y-%m-%d").date()
        except Exception:
            d = date.today()
        if d >= cutoff:
            counts[l.product_name] = counts.get(l.product_name, 0) + l.quantity
    items = sorted(counts.items(), key=lambda x: -x[1])[:5]
    out: List[ShoppingItemOut] = []
    for name, _ in items:
        out.append(ShoppingItemOut(
            id=0, product_id=None, product_name=name, quantity=1, unit="pcs",
            status="open", created_at=datetime.utcnow().isoformat()
        ))
    return out

# -------------------------------------------------
# Shopping advanced router (AA/BB/CC flow)
# -------------------------------------------------
shopping_router = APIRouter(prefix="/shopping", tags=["shopping"])

class ProductCreateIn(BaseModel):
    name: str
    quantity: float = Field(gt=0)
    expiry_date: Optional[str] = None
    location: Optional[str] = None

@shopping_router.post("/inventory/create")
def create_inventory_item(item: ProductCreateIn):
    if not item.name or item.quantity <= 0 or (item.expiry_date is None and item.location is None):
        raise HTTPException(422, "Données invalides (nom/quantité/infos manquantes).")
    p = _get_or_create_product(item.name)
    if item.location and item.location not in _STORAGE_LOCATIONS:
        raise HTTPException(422, "Emplacement invalide.")
    _add_lot(p, item.quantity, "pcs", today_str(), None, item.location, expiry_date=item.expiry_date)
    return {"ok": True, "product_id": p.id}

@shopping_router.post("/analyze/refresh")
def analyze_refresh():
    moved = _move_expired_to_history()
    scanned = _refresh_alerts()
    return {"expired_moved": moved, "alerts_added": scanned}

# --- AA sub-flow ---
class AAUserRow(BaseModel):
    name: str
    qty: float = 0

class AABuildIn(BaseModel):
    rows: List[AAUserRow]

@shopping_router.get("/aa")
def aa_get():
    # retourne la liste AA courante (ajouts libres côté utilisateur)
    return {"aa": dict(sorted(_AA_LIST.items()))}

class AARow(BaseModel):
    name: str
    qty: float = 1

@shopping_router.post("/aa/add")
def aa_add(item: AARow):
    nm = normalize_name(item.name)
    _get_or_create_product(nm)  # ensure product exists
    _AA_LIST[nm] = _AA_LIST.get(nm, 0.0) + float(item.qty or 0)
    return {"aa": dict(sorted(_AA_LIST.items()))}

@shopping_router.delete("/aa/item/{name}")
def aa_remove_item(name: str):
    nm = normalize_name(name)
    if nm in _AA_LIST:
        del _AA_LIST[nm]
    return {"aa": dict(sorted(_AA_LIST.items()))}

@shopping_router.delete("/aa/clear")
def aa_clear():
    _AA_LIST.clear()
    return {"aa": {}}

@shopping_router.post("/aa/build")
def build_aa(payload: AABuildIn):
    # Base: products seen in history but almost absent from stock
    hist_names = {h["product_name"] for h in _HISTORY_DB}
    by_name_qty: Dict[str, float] = {}
    for l in _LOTS_DB:
        by_name_qty[l.product_name] = by_name_qty.get(l.product_name, 0) + max(0, (l.quantity or 0) - (l.consumed or 0))

    aa: Dict[str, Dict[str, Any]] = {}
    for name in hist_names:
        if by_name_qty.get(name, 0) < 1:
            aa[name] = {"suggested_qty": 1.0}

    # Merge with user rows
    for r in payload.rows:
        nm = normalize_name(r.name)
        if nm in aa:
            aa[nm]["suggested_qty"] = max(aa[nm]["suggested_qty"], float(r.qty or 0))
        else:
            aa[nm] = {"suggested_qty": float(r.qty or 0)}

    # Merge with server-side AA list
    for nm, qty in _AA_LIST.items():
        if nm in aa:
            aa[nm]["suggested_qty"] = max(aa[nm]["suggested_qty"], float(qty))
        else:
            aa[nm] = {"suggested_qty": float(qty)}

    # Lots bucketed by color for each AA item
    lots = {}
    for name in aa.keys():
        lots[name] = {"rouge": [], "jaune": [], "vert": []}
        for l in _LOTS_DB:
            if normalize_name(l.product_name) == name:
                d = _days_to_expiry(l.expiry_date)
                if d is None:
                    continue
                bucket = "rouge" if d <= 3 else ("jaune" if d <= 10 else "vert")
                lots[name][bucket].append({"id": l.id, "qty": l.quantity, "days_left": d, "expiry_date": l.expiry_date})
        for b in ("rouge", "jaune", "vert"):
            lots[name][b].sort(key=lambda x: x["days_left"], reverse=True)

    # Validate (qty>0)
    validated = {n: {**meta, "status": "to_buy"} for n, meta in aa.items() if float(meta.get("suggested_qty", 0)) > 0}
    return {"aa": validated, "lots": lots}

# --- BB sub-flow ---
class PurchaseRow(BaseModel):
    name: str
    qty: float
    expiry_date: Optional[str] = None

class CheckoutIn(BaseModel):
    purchases: List[PurchaseRow]

@shopping_router.post("/bb/checkout")
def checkout_bb(payload: CheckoutIn):
    bb = []
    for r in payload.purchases:
        if r.qty <= 0:
            continue
        bb.append({"name": normalize_name(r.name), "qty": r.qty, "date_purchase": today_str(), "expiry_date": r.expiry_date})
    return {"bb": bb}

# --- CC sub-flow ---
class PlacementRow(BaseModel):
    name: str
    place: str

class CCClassifyIn(BaseModel):
    bb: List[PurchaseRow]
    placements: List[PlacementRow]

@shopping_router.post("/cc/classify")
def classify_cc(payload: CCClassifyIn):
    # Map placements by normalized product name
    place_by_name = {normalize_name(p.name): p.place for p in payload.placements}
    created_ids = []
    for it in payload.bb:
        nm = normalize_name(it.name)
        place = place_by_name.get(nm)
        if place not in _STORAGE_LOCATIONS:
            raise HTTPException(422, f"Lieu invalide: {place}")
        p = _get_or_create_product(nm)
        lot = _add_lot(p, it.qty, "pcs", today_str(), None, place, expiry_date=it.expiry_date)
        created_ids.append(lot.id)
    return {"ok": True, "created_lots": created_ids}

# Mount router
app.include_router(shopping_router)

# If you run:
# uvicorn freshkeeper.main:app --host 0.0.0.0 --port 8080
# this file should be located at freshkeeper/main.py

# --- /products (liste + création) ---
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy import text
from database import SessionLocal  # même import que dans alerts.py

products_router = APIRouter(prefix="/products", tags=["products"])

class ProductIn(BaseModel):
    name: str
    unit: Optional[str] = None
    category: Optional[str] = None

class ProductOut(ProductIn):
    id: int

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@products_router.get("", response_model=List[ProductOut])
def list_products(q: Optional[str] = Query(None, min_length=1), db: Session = Depends(get_db)):
    if q:
        rows = db.execute(text("""
            SELECT id, name, unit, category
            FROM products
            WHERE name ILIKE :q
            ORDER BY name
            LIMIT 200
        """), {"q": f"%{q}%"}).mappings().all()
    else:
        rows = db.execute(text("""
            SELECT id, name, unit, category
            FROM products
            ORDER BY name
            LIMIT 200
        """)).mappings().all()
    return rows

@products_router.post("", response_model=ProductOut, status_code=201)
def create_product(p: ProductIn, db: Session = Depends(get_db)):
    try:
        row = db.execute(text("""
            INSERT INTO products (name, unit, category)
            VALUES (:name, :unit, :category)
            RETURNING id, name, unit, category
        """), p.dict()).mappings().first()
        db.commit()
        return row
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=400, detail=str(e))

app.include_router(inventory_router)
app.include_router(maintenance_router)








from freshkeeper.api.suggest import suggest_product
app.add_api_route("/products/suggest", suggest_product, methods=["GET"])




app.include_router(suggest_router, prefix="/products")
app.include_router(products_router)

